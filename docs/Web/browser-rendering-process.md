---
slug: browser-rendering-process
title: 브라우저 렌더링 과정
---

## 탐색

- 사용자가 주소창에 URL 입력하는 경우
- 링크 클릭하는 경우
- 폼을 제출하는 동작

탐색이 완료될 때까지의 시간을 최소화 해야 함

### DNS 조회(DNS Lookup)

해당 페이지의 자원이 어디에 위치하는지 찾기

1. 브라우저는 DNS 조회 요청
2. 이름 서버에 의해서 처리되고, IP 주소로 응답
3. 최초의 요청 이후에, IP는 일정 기간 동안 캐시

- 이름 서버에 다시 연락하는 대신 캐시에서 IP 주소를 검색하여 후속 요청 속도를 높임
- DNS 조회는 보통 호스트 이름 하나당 한 번만 수행
- 요청된 페이지에서 참조하는 다른 호스트 이름에 대해서는 각각 수행해야 함
- 모바일 환경에서의 DNS 조회는 휴대폰에서 셀 타워에 가야하고, 셀 타워에서 권위 있는 DNS 서버에 도달해야 함

### TCP 핸드 셰이크

- IP 주소를 알고난 후에는, 브라우저는 서버와 TCP 3방향 핸드셰이크를 통해 연결을 설정
- 데이터를 전송하기 전에 통신하려는 두 주체가 TCP 소켓 연결을 위한 **매개변수를 주고 받을 수 있도록** 만들어짐
- SYN, SYN-ACK, ACK

### TLS 협상

- 통신 암호화에 쓰일 암호를 결정하고, 서버를 확인하고, 실제 데이터 전송 전에 안전한 연결이 이루어지도록 함
- 자원에 대한 실제 요청 전에 클라이언트에서 서버로 3번 더 왕복해야 함

## 응답

- 웹서버로 연결 성립 후 브라우저는 유저 대신에 초기 HTTP Get request를 보냄
  - HTML 파일을 요청하며, 서버가 요청을 받으면 관련 응답 헤더와 함께 HTML의 내용을 응답하게 됨
- TTFB(Time to First Byte): 사용자가 요청을 보내고 HTML의 첫 패킷을 받는데 걸린 시간
  - 첫 번째 컨텐츠 청크는 일반적으로 14kb 크기의 데이터

### 혼잡 제어 / TCP 슬로우 스타트

- TCP 패킷은 전송 중에 세그먼트로 분할됨
- TCP는 패킷의 순서를 보장하기 때문에 서버는 일정 개수의 세그먼트를 전송한 후 클라이언트로부터 ACK 패킷 형태로 승인을 받아야 함

- TCP 슬로우 스타트 알고리즘
  - 전송되는 세그먼트 수의 균형을 맞춤
  - 최대 네트워크 대역폭이 결정될 때까지 전송되는 데이터의 양을 점차적으로 늘리고 네트워크 부하가 높은 경우 전송되는 데이터의 양을 줄임
  - 전송할 세그먼트 수는 혼잡 윈도우 값에 의해 제어 (클라이언트가 ACK으로 보내야 하는 바이트 수)

## 구문 분석

- 브라우저가 네트워크를 통해 받은 데이터를 DOM이나 CSSOM으로 바꾸는 단계
- HTML이 14KB보다 크더라도, 브라우저는 받은 만큼 바로 파싱하고 렌더링 시작
  - 첫 14KB 안에 '화면에 처음 보일 최소한의 구조'를 넣는 게 중요

### DOM 트리 구축

- HTML 구문 분석: 토큰화와 트리 생성
  - HTML 토큰: 시작 및 종료 태그 그리고 속성 이름 및 값을 포함
- 논 블로킹 자원을 발견하면, 브라우저는 해당 자원을 요청하고 분석을 계속함
- CSS 파일을 만났을 때도 지속됨
- async, defer 같은 설정이 되어 있지 않은 script 태그는 렌더링을 막고, HTML의 분석을 중지시킴

### 프리로드 스캐너

- 브라우저가 DOM 트리를 만드는 프로세스는 메인스레드를 차지
- 프리로드 스캐너는 사용 가능한 컨텐츠를 분석하고 CSS나 JS, 웹 폰트 같이 우선순위가 높은 자원을 요청

```html
<link rel="stylesheet" src="styles.css" />
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description" />
<script src="anotherscript.js" async></script>
```

- 메인 스레드가 html과 css를 분석하고 있을 때, 프리로드 스캐너는 스크립트와 이미지를 찾아 다운로드 하기 시작
- js의 분석과 실행 순서가 중요하지 않고 스크립트가 프로세스를 막지 않도록 하려면 async 속성이나 defer 속성 추가
- CSS를 다운로드하는 것은 HTML 분석이나 다운로드를 막지 않으나, JS 실행은 막음

### CSSOM 구축

- CSS 객체 모델은 DOM과 비슷
- 브라우저는 CSS 규칙을 이해할 수 있고 작업을 진행할 수 있도록 스타일 맵으로 변환

### 다른 작업들

#### JavaScript 컴파일

- CSSOM이 생성되는 동안 프리스캐너 덕에 JS 파일 같은 다른 자원도 다운로드 됨
- JS는 해석, 컴파일, 구문 분석 및 실행되며, 스크립트는 추상 구문 트리로 구문 분석 됨
- 그 결과 메인스레드에서 실행되는 바이트코드가 생성됨

#### 접근성 트리 구축

- 브라우저는 접근성 트리를 만듦
- 브라우저는 DOM이 업데이트될 때 접근성 트리도 업데이트
- AOM(접근성 객체 모델)이 만들어지기 전까지, 홤녀 리더기는 컨텐츠에 접근할 수 없음

## 렌더

- 스타일, 레이아웃, 페인트, 합성 포함
- 렌더 트리: CSSOM과 DOM 트리가 구문 분석되는 과정에서 생성된 후 렌더트리로 합성됨
  - 보이는 요소의 레이아웃 계산, 화면에 페인트

### 스타일

- 렌더트리(계산된 스타일 트리)는 DOM 트리의 루트부터 시작하여 눈에 보이는 노드를 순회하며 만들어짐
- 각각의 보이는 노드는 그 노드에 적용된 CSSOM 규칙이 있음

### 레이아웃

- 렌더 트리를 기반으로 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행함
- 레이아웃: 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정하는 프로세스
  - 페이지에서 각 객체의 크기와 위치 계산
- 리플로우: 레이아웃 이후에 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정

### 페인트

- 각 노드를 화면에 페인팅
- 페인팅 혹은 레지스터화 단계에서 브라우저는 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환
- 페인팅은 레이아웃 트리의 요소를 레이어로 분리
  - 컨텐츠를 CPU의 메인스레드에서 GPU 레이어로 격상하는 것은 페인트 및 리페인트 성능을 높임

### 합성

- 문서의 각 섹션이 다른 레이어에서 그려질 때, 섹션을 겹쳐 놓으면서 그것들이 올바른 순서로 화면에 그려지는 것과 정확한 렌더링을 보장하기 위해 합성 필요
